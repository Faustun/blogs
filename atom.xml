<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SongZhiguo</title>
  
  
  <link href="/blogs/atom.xml" rel="self"/>
  
  <link href="https://songzhiguo.github.io/blogs/"/>
  <updated>2018-06-25T10:32:53.652Z</updated>
  <id>https://songzhiguo.github.io/blogs/</id>
  
  <author>
    <name>Songzhiguo powered by Hexo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端面试总结</title>
    <link href="https://songzhiguo.github.io/blogs/2018/06/25/js-basics/"/>
    <id>https://songzhiguo.github.io/blogs/2018/06/25/js-basics/</id>
    <published>2018-06-25T09:30:32.000Z</published>
    <updated>2018-06-25T10:32:53.652Z</updated>
    
    <content type="html"><![CDATA[<h3 id="变量类型和计算"><a href="#变量类型和计算" class="headerlink" title="变量类型和计算"></a>变量类型和计算</h3><h4 id="typeof运算符"><a href="#typeof运算符" class="headerlink" title="typeof运算符"></a>typeof运算符</h4><p>typeof运算符可以详细区分值类型，引用类型只能区分object和function<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// undefined</span></div><div class="line"><span class="keyword">typeof</span> <span class="string">'abc'</span> <span class="comment">// string</span></div><div class="line"><span class="keyword">typeof</span> <span class="number">123</span>  <span class="comment">// number</span></div><div class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// boolean</span></div><div class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// object</span></div><div class="line"><span class="keyword">typeof</span> [] <span class="comment">// object</span></div><div class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// object</span></div><div class="line"><span class="keyword">typeof</span> <span class="built_in">console</span>.log <span class="comment">// function</span></div></pre></td></tr></table></figure></p><h4 id="变量计算-强制类型转换"><a href="#变量计算-强制类型转换" class="headerlink" title="变量计算 - 强制类型转换"></a>变量计算 - 强制类型转换</h4><p>-&gt; 字符串拼接<br>-&gt; ==运算符<br>-&gt; if语句<br>-&gt; 逻辑运算符</p><h4 id="js中的内置函数"><a href="#js中的内置函数" class="headerlink" title="js中的内置函数"></a>js中的内置函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span></div><div class="line"><span class="built_in">Array</span></div><div class="line"><span class="built_in">Boolean</span></div><div class="line"><span class="built_in">Number</span></div><div class="line"><span class="built_in">String</span></div><div class="line"><span class="built_in">Function</span></div><div class="line"><span class="built_in">Date</span></div><div class="line"><span class="built_in">RegExp</span></div><div class="line"><span class="built_in">Error</span></div></pre></td></tr></table></figure><h4 id="js按存储方式区分变量类型"><a href="#js按存储方式区分变量类型" class="headerlink" title="js按存储方式区分变量类型"></a>js按存储方式区分变量类型</h4><p>值类型和引用类型</p><h4 id="如何理解JSON"><a href="#如何理解JSON" class="headerlink" title="如何理解JSON"></a>如何理解JSON</h4><p>JSON是一个js对象而已</p><h4 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h4><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;变量类型和计算&quot;&gt;&lt;a href=&quot;#变量类型和计算&quot; class=&quot;headerlink&quot; title=&quot;变量类型和计算&quot;&gt;&lt;/a&gt;变量类型和计算&lt;/h3&gt;&lt;h4 id=&quot;typeof运算符&quot;&gt;&lt;a href=&quot;#typeof运算符&quot; class=&quot;header
      
    
    </summary>
    
      <category term="js" scheme="https://songzhiguo.github.io/blogs/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>let和const命令</title>
    <link href="https://songzhiguo.github.io/blogs/2018/06/06/let-const/"/>
    <id>https://songzhiguo.github.io/blogs/2018/06/06/let-const/</id>
    <published>2018-06-06T01:48:19.000Z</published>
    <updated>2018-06-06T02:04:43.198Z</updated>
    
    <content type="html"><![CDATA[<p>ES6新增let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。</p><a id="more"></a><p>ES6新增let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。<br>不存在变量提升</p><p>暂时性死区<br>只要在块级作用域内存在let命令，他所声明的变量就绑定这个区域，不在受外部影响。</p><p>ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就是用这些变量，就会报错。<br>在代码块内，使用let声明变量之前，改变量都是不可用的，这在语法上称为暂时性死区</p><p>不允许重复声明</p><p>为什么需要块级作用域<br>第一种场景，内层变量可能会覆盖外层变量<br>第二种场景，用来计数的循环变量泄露为全局变量</p><p>const声明一个只读的常量，一旦声明常量的值就不能改变。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6新增let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://songzhiguo.github.io/blogs/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>理解vue生命周期</title>
    <link href="https://songzhiguo.github.io/blogs/2018/06/01/vue-lifecycle/"/>
    <id>https://songzhiguo.github.io/blogs/2018/06/01/vue-lifecycle/</id>
    <published>2018-06-01T03:49:44.000Z</published>
    <updated>2018-06-05T08:10:29.035Z</updated>
    
    <content type="html"><![CDATA[<p>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等<br><a id="more"></a></p><p><img src="https://cn.vuejs.org/images/lifecycle.png" alt=""></p><p>在谈到Vue的生命周期的时候，我们首先需要创建一个实例，也就是在 new Vue ( ) 的对象过程当中，首先执行了init（init是vue组件里面默认去执行的），在init的过程当中首先调用了beforeCreate，然后在injections（注射）和reactivity（反应性）的时候，它会再去调用created。所以在init的时候，事件已经调用了，我们在beforeCreate的时候千万不要去修改data里面赋值的数据，最早也要放在created里面去做（添加一些行为）。</p><p>当created完成之后，它会去判断instance（实例）里面是否含有“el”option（选项），如果没有的话，它会调用vm.$mount(el)这个方法，然后执行下一步；如果有的话，直接执行下一步。紧接着会判断是否含有“template”这个选项，如果有的话，它会把template解析成一个render function ，这是一个template编译的过程，结果是解析成了render函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">render (h) &#123;</div><div class="line">  <span class="keyword">return</span> h(<span class="string">'div'</span>, &#123;&#125;, <span class="keyword">this</span>.text)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>解释一下，render函数里面的传参h就是Vue里面的createElement方法，return返回一个createElement方法，其中要传3个参数，第一个参数就是创建的div标签；第二个参数传了一个对象，对象里面可以是我们组件上面的props，或者是事件之类的东西；第三个参数就是div标签里面的内容，这里我们指向了data里面的text。</p><p>使用render函数的结果和我们之前使用template解析出来的结果是一样的。render函数是发生在beforeMount和mounted之间的，这也从侧面说明了，在beforeMount的时候，$el还只是我们在HTML里面写的节点，然后到mounted的时候，它就把渲染出来的内容挂载到了DOM节点上。这中间的过程其实是执行了render function的内容。</p><p>在使用.vue文件开发的过程当中，我们在里面写了template模板，在经过了vue-loader的处理之后，就变成了render function，最终放到了vue-loader解析过的文件里面。这样做有什么好处呢？原因是由于在解析template变成render function的过程，是一个非常耗时的过程，vue-loader帮我们处理了这些内容之后，当我们在页面上执行vue代码的时候，效率会变得更高。</p><p>beforeMount在有了render function的时候才会执行，当执行完render function之后，就会调用mounted这个钩子，在mounted挂载完毕之后，这个实例就算是走完流程了。<br>后续的钩子函数执行的过程都是需要外部的触发才会执行。比如说有数据的变化，会调用beforeUpdate，然后经过Virtual DOM，最后updated更新完毕。当组件被销毁的时候，它会调用beforeDestory，以及destoryed。</p><blockquote><ul><li>beforecreated：el 和 data 并未初始化 </li><li>created:完成了 data 数据的初始化，el没有</li><li>beforeMount：完成了 el 和 data 初始化 </li><li>mounted ：完成Dom挂载</li><li>DOM相关操作放在mounted之后,数据相关操作，可以放在created，也可以放在mounted里面</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等&lt;br&gt;
    
    </summary>
    
      <category term="vue" scheme="https://songzhiguo.github.io/blogs/categories/vue/"/>
    
    
  </entry>
  
  <entry>
    <title>进程与线程的一个简单解释</title>
    <link href="https://songzhiguo.github.io/blogs/2018/06/01/process-thread/"/>
    <id>https://songzhiguo.github.io/blogs/2018/06/01/process-thread/</id>
    <published>2018-06-01T03:14:52.000Z</published>
    <updated>2018-06-01T03:22:38.224Z</updated>
    
    <content type="html"><![CDATA[<p>计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。<br><a id="more"></a></p><p><a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="external">进程与线程的一个简单解释</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。&lt;br&gt;
    
    </summary>
    
      <category term="计算机基础" scheme="https://songzhiguo.github.io/blogs/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>vue中删除数组指定数据产生渲染错乱</title>
    <link href="https://songzhiguo.github.io/blogs/2018/05/25/vue-forRender/"/>
    <id>https://songzhiguo.github.io/blogs/2018/05/25/vue-forRender/</id>
    <published>2018-05-25T04:03:09.000Z</published>
    <updated>2018-05-25T04:23:23.426Z</updated>
    
    <content type="html"><![CDATA[<p>在vue项目中，删除数组中的指定数据，造成页面列表渲染错乱问题及解决方案<br><a id="more"></a></p><p>最近使用vue开发一个ppt在线编辑工具时，要创建ppt元素，ppt的每一页中的每一个元素都是用v-for来做循环，动态添加删除，</p><p>出现的问题是，删除非数组的最后一个数据时，dom元素消失的同样是最后一个，数据渲染就会往上错位一个。</p><p>解决方案是</p><p>问题是出在v-for的:key上，解决方法就是给:key赋予一个独一无二的值。这样绑定的数组就可以和dom对象一一对应起来，删除的时候也能正确删除掉响应dom对象了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// utils</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">guid</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'</span>.replace(<span class="regexp">/[xy]/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">c</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> r = <span class="built_in">Math</span>.random() * <span class="number">16</span> | <span class="number">0</span></div><div class="line">    <span class="keyword">let</span> v = c === <span class="string">'x'</span> ? r : (r &amp; <span class="number">0x3</span> | <span class="number">0x8</span>)</div><div class="line">    <span class="keyword">return</span> v.toString(<span class="number">16</span>)</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 组件内</span></div><div class="line"><span class="keyword">import</span> &#123;guid&#125; <span class="keyword">from</span> <span class="string">'@/utils/index'</span></div><div class="line"></div><div class="line"><span class="comment">// 添加文本</span></div><div class="line">addText() &#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.canQuill) &#123;</div><div class="line">    <span class="keyword">let</span> obj = &#123; <span class="attr">words</span>: <span class="string">'文本'</span>,</div><div class="line">      backfillStyle: &#123;&#125;,</div><div class="line">      style: <span class="literal">null</span>, <span class="attr">WHXY</span>: &#123; <span class="attr">w</span>: <span class="number">372</span>, <span class="attr">h</span>: <span class="string">'auto'</span>, <span class="attr">x</span>: <span class="number">266</span>, <span class="attr">y</span>: <span class="number">350</span> &#125;,</div><div class="line">      inputAct: <span class="literal">true</span>,</div><div class="line">      animat: &#123;</div><div class="line">        type: <span class="string">''</span>,</div><div class="line">        duration: <span class="number">0</span>,</div><div class="line">        delay: <span class="number">0</span></div><div class="line">      &#125;,</div><div class="line">      guid: guid()</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.pages[<span class="keyword">this</span>.currentPage - <span class="number">1</span>].text.push(obj)</div><div class="line">    <span class="keyword">this</span>._initFillData(<span class="string">'text'</span>, obj, <span class="literal">true</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">vue-draggable-resizable</span></span></div><div class="line"><span class="tag">  <span class="attr">v-for</span>=<span class="string">"(item, index) in page.text"</span></span></div><div class="line"><span class="tag">  <span class="attr">:key</span>=<span class="string">"item.guid"</span></span></div><div class="line"><span class="tag">  <span class="attr">:data-animation-type</span>=<span class="string">"item.animat.type"</span></span></div><div class="line"><span class="tag">  <span class="attr">:data-transition-duration</span>=<span class="string">"item.animat.duration"</span></span></div><div class="line"><span class="tag">  <span class="attr">:data-transition-delay</span>=<span class="string">"item.animat.delay"</span></span></div><div class="line"><span class="tag">  <span class="attr">:parent</span>=<span class="string">"true"</span></span></div><div class="line"><span class="tag">  <span class="attr">:handles</span>=<span class="string">"['ml','mr']"</span></span></div><div class="line"><span class="tag">  <span class="attr">:style</span>=<span class="string">"item.backfillStyle"</span></span></div><div class="line"><span class="tag">  <span class="attr">:w</span>=<span class="string">"parseInt(item.WHXY.w)"</span></span></div><div class="line"><span class="tag">  <span class="attr">:h</span>=<span class="string">"parseInt(item.WHXY.h)"</span></span></div><div class="line"><span class="tag">  <span class="attr">:x</span>=<span class="string">"parseInt(item.WHXY.x)"</span></span></div><div class="line"><span class="tag">  <span class="attr">:y</span>=<span class="string">"parseInt(item.WHXY.y)"</span></span></div><div class="line"><span class="tag">  <span class="attr">:draggable</span>=<span class="string">"draggable"</span></span></div><div class="line"><span class="tag">  <span class="attr">ref</span>=<span class="string">"pluginText"</span></span></div><div class="line"><span class="tag">  <span class="attr">text</span></span></div><div class="line"><span class="tag">  @<span class="attr">dblclickHandle</span>=<span class="string">"dblclickHandle"</span></span></div><div class="line"><span class="tag">  @<span class="attr">activated</span>=<span class="string">"onActivateText(index)"</span></span></div><div class="line"><span class="tag">  @<span class="attr">deactivated</span>=<span class="string">"onDeactivateText(index)"</span></span></div><div class="line"><span class="tag">&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"quill-text"</span> <span class="attr">ref</span>=<span class="string">"text"</span> <span class="attr">v-show</span>=<span class="string">"item.inputAct"</span> <span class="attr">v-html</span>=<span class="string">"item.words"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"quill-text quill"</span> <span class="attr">ref</span>=<span class="string">"quill"</span> <span class="attr">v-show</span>=<span class="string">"!item.inputAct"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">vue-draggable-resizable</span>&gt;</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在vue项目中，删除数组中的指定数据，造成页面列表渲染错乱问题及解决方案&lt;br&gt;
    
    </summary>
    
      <category term="pit" scheme="https://songzhiguo.github.io/blogs/categories/pit/"/>
    
    
      <category term="pit" scheme="https://songzhiguo.github.io/blogs/tags/pit/"/>
    
  </entry>
  
  <entry>
    <title>vue上传七牛云</title>
    <link href="https://songzhiguo.github.io/blogs/2018/05/11/uploadqiniu/"/>
    <id>https://songzhiguo.github.io/blogs/2018/05/11/uploadqiniu/</id>
    <published>2018-05-11T06:06:19.000Z</published>
    <updated>2018-05-25T05:00:25.397Z</updated>
    
    <content type="html"><![CDATA[<p>使用element-ui上传七牛云方法介绍<br><a id="more"></a></p><p>####上传组件<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">el-upload</span></span></div><div class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"upload-demo"</span></span></div><div class="line"><span class="tag">  <span class="attr">:data</span>=<span class="string">"form"</span></span></div><div class="line"><span class="tag">  <span class="attr">:on-success</span>=<span class="string">"handleAvatarSuccess"</span></span></div><div class="line"><span class="tag">  <span class="attr">:on-error</span>=<span class="string">"handleError"</span></span></div><div class="line"><span class="tag">  <span class="attr">:before-upload</span>=<span class="string">"beforeAvatarUpload"</span></span></div><div class="line"><span class="tag">  <span class="attr">action</span>=<span class="string">"//up.qbox.me/"</span></span></div><div class="line"><span class="tag">&gt;</span></div></pre></td></tr></table></figure></p><p>####传参token值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">data() &#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    form: <span class="literal">null</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>####保证初次上传token已成功传入<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mounted() &#123;</div><div class="line">  <span class="keyword">this</span>._getToken()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">methods: &#123;</div><div class="line">  handleAvatarSuccess(res, file) &#123;   <span class="comment">//上传成功后在图片框显示图片</span></div><div class="line">    <span class="comment">// this.imageUrl ='http://oq34prjoz.bkt.clouddn.com/'+ res.key</span></div><div class="line">    <span class="built_in">console</span>.log(res)</div><div class="line">  &#125;,</div><div class="line">  handleError(res) &#123;   <span class="comment">//显示错误</span></div><div class="line">    <span class="built_in">console</span>.log(res)</div><div class="line">  &#125;,</div><div class="line">  beforeAvatarUpload(file) &#123;   <span class="comment">//在图片提交前进行验证</span></div><div class="line">    <span class="keyword">this</span>._getToken()</div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 从服务器获取token值</span></div><div class="line">  _getToken() &#123;</div><div class="line">    getToken().then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">this</span>.form = &#123;</div><div class="line">        token: response.data</div><div class="line">      &#125;</div><div class="line">    &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用element-ui上传七牛云方法介绍&lt;br&gt;
    
    </summary>
    
      <category term="pit" scheme="https://songzhiguo.github.io/blogs/categories/pit/"/>
    
    
      <category term="vue" scheme="https://songzhiguo.github.io/blogs/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>使用扩展符会报错问题</title>
    <link href="https://songzhiguo.github.io/blogs/2018/04/27/record-element/"/>
    <id>https://songzhiguo.github.io/blogs/2018/04/27/record-element/</id>
    <published>2018-04-27T06:24:19.000Z</published>
    <updated>2018-05-25T04:57:05.464Z</updated>
    
    <content type="html"><![CDATA[<p>按照element-ui官网修改 .babelrc导致使用扩展符会报错问题<br><a id="more"></a></p><h3 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h3><p>  按照官网将 .babelrc 修改为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"presets"</span>: [[<span class="string">"es2015"</span>, &#123; <span class="attr">"modules"</span>: <span class="literal">false</span> &#125;]],</div><div class="line">  <span class="attr">"plugins"</span>: [</div><div class="line">    [</div><div class="line">      <span class="string">"component"</span>,</div><div class="line">      &#123;</div><div class="line">        <span class="attr">"libraryName"</span>: <span class="string">"element-ui"</span>,</div><div class="line">        <span class="attr">"styleLibraryName"</span>: <span class="string">"theme-chalk"</span></div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>使用扩展符会报错<br>在将.babelrc 修改为</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"presets"</span>: [[<span class="string">"es2015"</span>, &#123; <span class="attr">"modules"</span>: <span class="literal">false</span> &#125;], <span class="string">"stage-3"</span>],</div><div class="line">  <span class="attr">"plugins"</span>: [</div><div class="line">    [</div><div class="line">      <span class="string">"component"</span>,</div><div class="line">      &#123;</div><div class="line">        <span class="attr">"libraryName"</span>: <span class="string">"element-ui"</span>,</div><div class="line">        <span class="attr">"styleLibraryName"</span>: <span class="string">"theme-chalk"</span></div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;按照element-ui官网修改 .babelrc导致使用扩展符会报错问题&lt;br&gt;
    
    </summary>
    
      <category term="pit" scheme="https://songzhiguo.github.io/blogs/categories/pit/"/>
    
    
      <category term="vue" scheme="https://songzhiguo.github.io/blogs/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>使用axios post后台获取不到提交的数据</title>
    <link href="https://songzhiguo.github.io/blogs/2018/03/28/axios/"/>
    <id>https://songzhiguo.github.io/blogs/2018/03/28/axios/</id>
    <published>2018-03-28T11:55:30.000Z</published>
    <updated>2018-05-25T04:51:32.153Z</updated>
    
    <content type="html"><![CDATA[<p>使用axios post 提交数据,后台获取不到数据解决方案<br><a id="more"></a></p><p>在页面中引用 qs :   var qs = require(‘qs’)</p><p>同时 需要将 请求头headers改为： ‘Content-Type’: ‘application/x-www-form-urlencoded’,</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">addDaily</span> (<span class="params">parameter</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> url = PUBLIC_URL + <span class="string">'daily/addDatas'</span></div><div class="line"></div><div class="line">  <span class="keyword">return</span> axios.post(url, qs.stringify(parameter), &#123;</div><div class="line">    headers: &#123;</div><div class="line">      <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span></div><div class="line">    &#125;</div><div class="line">  &#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(res.data)</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>或者在拦截器中统一处理<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">service.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">if</span> (store.getters.token) &#123;</div><div class="line">    config.headers[<span class="string">'X-Token'</span>] = getToken() <span class="comment">// 让每个请求携带自定义token 请根据实际情况自行修改</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (config.method === <span class="string">'post'</span>) &#123;</div><div class="line">    config.data = qs.stringify(config.data)</div><div class="line">    config.headers[<span class="string">'Content-Type'</span>] = <span class="string">'application/x-www-form-urlencoded'</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> config</div><div class="line">&#125;, error =&gt; &#123;</div><div class="line">  <span class="comment">// Do something with request error</span></div><div class="line">  <span class="built_in">console</span>.log(error) <span class="comment">// for debug</span></div><div class="line">  <span class="built_in">Promise</span>.reject(error)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用axios post 提交数据,后台获取不到数据解决方案&lt;br&gt;
    
    </summary>
    
      <category term="pit" scheme="https://songzhiguo.github.io/blogs/categories/pit/"/>
    
    
      <category term="vue" scheme="https://songzhiguo.github.io/blogs/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>理解vue中的组件通信</title>
    <link href="https://songzhiguo.github.io/blogs/2018/03/17/assembly-vue/"/>
    <id>https://songzhiguo.github.io/blogs/2018/03/17/assembly-vue/</id>
    <published>2018-03-17T00:57:14.000Z</published>
    <updated>2018-05-08T02:53:22.595Z</updated>
    
    <content type="html"><![CDATA[<p>组件最常见的就是形成父子组件的关系，父组件可能要给子组件下发数据，子组件则可能要将它内部发生的事情告知父组件。</p><p>在 Vue 中，父子组件的关系可以总结为 prop 向下传递，事件向上传递。父组件通过 prop 给子组件下发数据，子组件通过事件给父组件发送消息。看看它们是怎么工作的。</p><p><img src="https://cn.vuejs.org/images/props-events.png" alt=""></p><h3 id="使用-Prop-传递数据"><a href="#使用-Prop-传递数据" class="headerlink" title="使用 Prop 传递数据"></a>使用 Prop 传递数据</h3><p>组件实例的作用域是孤立的。这意味着不能 (也不应该) 在子组件的模板内直接引用父组件的数据。父组件的数据需要通过 prop 才能下发到子组件中。</p><p>子组件要显式地用 props 选项声明它预期的数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">props: [<span class="string">'message'</span>]</div></pre></td></tr></table></figure><h4 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h4><p>父组件更新时，子组件的所有 prop 都会更新为最新值。这意味着你不应该在子组件内部改变 prop</p><p>在两种情况下，我们很容易忍不住想去修改 prop 中数据：</p><p>1、Prop 作为初始值传入后，子组件想把它当作局部数据来用；</p><p>2、Prop 作为原始数据传入，由子组件处理成其它数据输出。</p><p>对这两种情况，正确的应对方式是：</p><p>1、定义一个局部变量，并用 prop 的值初始化它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">props: [<span class="string">'initialCounter'</span>],</div><div class="line">data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123; <span class="attr">counter</span>: <span class="keyword">this</span>.initialCounter &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>2、定义一个计算属性，处理 prop 的值并返回：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">props: [<span class="string">'size'</span>],</div><div class="line">computed: &#123;</div><div class="line">  normalizedSize: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size.trim().toLowerCase()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><ul><li>注意在 JavaScript 中对象和数组是引用类型，指向同一个内存空间，如果 prop 是一个对象或数组，在子组件内部改变它会影响父组件的状态。</li></ul></blockquote><h4 id="Prop-验证"><a href="#Prop-验证" class="headerlink" title="Prop 验证"></a>Prop 验证</h4><p>要指定验证规则，需要用对象的形式来定义 prop，而不能用字符串数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">props: &#123;</div><div class="line">    <span class="comment">// 基础类型检测 (`null` 指允许任何类型)</span></div><div class="line">    propA: <span class="built_in">Number</span>,</div><div class="line">    <span class="comment">// 可能是多种类型</span></div><div class="line">    propB: [<span class="built_in">String</span>, <span class="built_in">Number</span>],</div><div class="line">    <span class="comment">// 必传且是字符串</span></div><div class="line">    propC: &#123;</div><div class="line">      type: <span class="built_in">String</span>,</div><div class="line">      required: <span class="literal">true</span></div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// 数值且有默认值</span></div><div class="line">    propD: &#123;</div><div class="line">      type: <span class="built_in">Number</span>,</div><div class="line">      <span class="keyword">default</span>: <span class="number">100</span></div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// 数组/对象的默认值应当由一个工厂函数返回</span></div><div class="line">    propE: &#123;</div><div class="line">      type: <span class="built_in">Object</span>,</div><div class="line">      <span class="keyword">default</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> &#123; <span class="attr">message</span>: <span class="string">'hello'</span> &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// 自定义验证函数</span></div><div class="line">    propF: &#123;</div><div class="line">      validator: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> value &gt; <span class="number">10</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;组件最常见的就是形成父子组件的关系，父组件可能要给子组件下发数据，子组件则可能要将它内部发生的事情告知父组件。&lt;/p&gt;
&lt;p&gt;在 Vue 中，父子组件的关系可以总结为 prop 向下传递，事件向上传递。父组件通过 prop 给子组件下发数据，子组件通过事件给父组件发送消息。
      
    
    </summary>
    
      <category term="Vue" scheme="https://songzhiguo.github.io/blogs/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>构造函数与原型对象</title>
    <link href="https://songzhiguo.github.io/blogs/2018/03/15/setup-obj/"/>
    <id>https://songzhiguo.github.io/blogs/2018/03/15/setup-obj/</id>
    <published>2018-03-15T06:19:08.000Z</published>
    <updated>2018-05-25T04:28:40.171Z</updated>
    
    <content type="html"><![CDATA[<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。</p><p>构造函数本身也是函数，只不过可以用来创建对象而已</p><p>创建实例对象，需要使用new操作符，以这种方式调用构造函数实际上会经历以下4个步骤</p><blockquote><ul><li>1、创建一个新对象；</li><li>2、将构造函数的作用域赋值给新对象（因此this就指向了这个新对象）；</li><li>3、执行构造函数中的代码（为这个新对象添加属性）；</li><li>4、返回新对象</li></ul></blockquote><h3 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h3><p>我们创建的每一个函数都有一个prototype,这个属性指向函数的原型对象,在默认情况下，所有原型对象都<br>会自动获得一个constructor（构造函数）属性。这个属性包含一个指向prototype属性所在函数的指针</p><p>创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性；至于其他方法，则都是从Object继承而来的。</p><p>当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。<br>ECMA-262第5版中管这个指针叫[[Prototype]]。虽然在脚本中没有标准的方式访问[[Prototype]]，但Firefox、Safari和Chrome在每个对象上都支持一个属性<strong>proto</strong>；这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">Person.prototype.name = “Nicholas”;</div><div class="line">Person.prototype.age = <span class="number">29</span>;</div><div class="line">Person.prototype.job = “Software Engineer”;</div><div class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div><div class="line">person1.sayName(); <span class="comment">//“Nicholas”</span></div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</div><div class="line">person2.sayName(); <span class="comment">//“Nicholas”</span></div><div class="line">alert(person1.sayName == person2.sayName); <span class="comment">//true</span></div></pre></td></tr></table></figure><p>以前面使用Person构造函数和Person.prototype创建实例的代码为例，如图</p><p><img src="https://songzhiguo.github.io/lib/images/prototype.jpg" alt=""></p><p>在此，Person.prototype指向了原型对象，而Person.prototype.constructor又指回了Person。</p><p>原型对象中除了包含constructor属性之外，还包括后来添加的其他属性。Person的每个实例——person1和person2都包含一个内部属性，该属性仅仅指向了Person.prototype；换句话说，它们与构造函数没有直接的关系。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;构造函数&quot;&gt;&lt;a href=&quot;#构造函数&quot; class=&quot;headerlink&quot; title=&quot;构造函数&quot;&gt;&lt;/a&gt;构造函数&lt;/h3&gt;&lt;p&gt;按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。&lt;/p&gt;
&lt;p&gt;构造函数本身也是函数，
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://songzhiguo.github.io/blogs/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>python学习网站</title>
    <link href="https://songzhiguo.github.io/blogs/2018/02/12/pythonWeb/"/>
    <id>https://songzhiguo.github.io/blogs/2018/02/12/pythonWeb/</id>
    <published>2018-02-12T01:19:58.000Z</published>
    <updated>2018-03-12T04:36:40.684Z</updated>
    
    <content type="html"><![CDATA[<h4 id="国内python学习网站"><a href="#国内python学习网站" class="headerlink" title="国内python学习网站"></a>国内python学习网站</h4><table><thead><tr><th>名称</th><th>地址</th><th>介绍</th></tr></thead><tbody><tr><td>PythonTip</td><td><a href="http://www.pythontip.com/" target="_blank" rel="external">http://www.pythontip.com/</a></td><td>提供python入门教程， 技术交流， 在线实践等一条龙服务</td></tr><tr><td>菜鸟教程</td><td><a href="http://www.runoob.com/python/python-tutorial.html" target="_blank" rel="external">http://www.runoob.com/python/python-tutorial.html</a></td><td>在线python学习–可编辑运行的</td></tr><tr><td>编程教室</td><td><a href="http://crossincode.com/home/" target="_blank" rel="external">http://crossincode.com/home/</a></td><td>Crossin的编程教室 - 编程世界的新手村</td></tr><tr><td>菜鸟工具</td><td><a href="https://c.runoob.com/compile/9" target="_blank" rel="external">https://c.runoob.com/compile/9</a></td><td>在线Python编辑器</td></tr><tr><td>代码测试</td><td><a href="http://www.dooccn.com/python3/" target="_blank" rel="external">http://www.dooccn.com/python3/</a></td><td>在线Python编辑器</td></tr><tr><td>在线工具</td><td><a href="https://tool.lu/coderunner/" target="_blank" rel="external">https://tool.lu/coderunner/</a></td><td>在线Python编辑器</td></tr></tbody></table><h4 id="国外python学习网站"><a href="#国外python学习网站" class="headerlink" title="国外python学习网站"></a>国外python学习网站</h4><table><thead><tr><th>名称</th><th>地址</th><th>介绍</th></tr></thead><tbody><tr><td>python官网</td><td><a href="https://www.python.org/" target="_blank" rel="external">https://www.python.org/</a></td><td>python官网</td></tr><tr><td>Python指南</td><td><a href="http://docs.python-guide.org/" target="_blank" rel="external">http://docs.python-guide.org/</a></td><td>Python指南对于Python的方方面面都有指导作用</td></tr><tr><td>codecademy</td><td><a href="https://www.codecademy.com/" target="_blank" rel="external">https://www.codecademy.com/</a></td><td>在线python学习—可编辑运行的</td></tr><tr><td>codingbat</td><td><a href="http://codingbat.com/python" target="_blank" rel="external">http://codingbat.com/python</a></td><td>在线python学习—可编辑运行的</td></tr><tr><td>pyschools</td><td><a href="http://www.pyschools.com/" target="_blank" rel="external">http://www.pyschools.com/</a></td><td>在线python学习—可编辑运行的</td></tr><tr><td>codeschool</td><td><a href="https://www.codeschool.com/courses/try-python" target="_blank" rel="external">https://www.codeschool.com/courses/try-python</a></td><td>在线python学习—可编辑运行的</td></tr><tr><td>pythontutor</td><td><a href="http://www.pythontutor.com/" target="_blank" rel="external">http://www.pythontutor.com/</a></td><td>通过可视化代码执行来学习编程</td></tr><tr><td>tutorialspoint</td><td><a href="http://www.tutorialspoint.com/python/" target="_blank" rel="external">http://www.tutorialspoint.com/python/</a></td><td>在线python学习–可编辑运行的</td></tr><tr><td>learnpython</td><td><a href="http://www.learnpython.org/" target="_blank" rel="external">http://www.learnpython.org/</a></td><td>在线python学习–可编辑运行的</td></tr><tr><td>CheckiO</td><td><a href="https://py.checkio.org/" target="_blank" rel="external">https://py.checkio.org/</a></td><td>闯关游戏类的python在线编辑网站</td></tr></tbody></table><h4 id="国内少儿学习编程的网站"><a href="#国内少儿学习编程的网站" class="headerlink" title="国内少儿学习编程的网站"></a>国内少儿学习编程的网站</h4><table><thead><tr><th>名称</th><th>地址</th><th>介绍</th></tr></thead><tbody><tr><td>少儿编程网</td><td><a href="http://www.kidscode.cn/python" target="_blank" rel="external">http://www.kidscode.cn/python</a></td><td>面向少儿的python教程</td></tr><tr><td>编玩边学</td><td><a href="https://www.codepku.com/" target="_blank" rel="external">https://www.codepku.com/</a></td><td>少儿编程编学边玩</td></tr><tr><td>编程猫</td><td><a href="https://hi.codemao.cn/home" target="_blank" rel="external">https://hi.codemao.cn/home</a></td><td>少儿学编程</td></tr><tr><td>helloworldroom</td><td><a href="http://www.helloworldroom.com/" target="_blank" rel="external">http://www.helloworldroom.com/</a></td><td>少儿编程网校</td></tr><tr><td>西瓜创客</td><td><a href="https://www.xiguacity.cn/main/home" target="_blank" rel="external">https://www.xiguacity.cn/main/home</a></td><td>少儿 Scratch 编程营</td></tr><tr><td>码上玩</td><td><a href="http://www.code666.com/" target="_blank" rel="external">http://www.code666.com/</a></td><td>少儿编程网校</td></tr><tr><td>码趣学院</td><td><a href="http://www.codingmarch.com/" target="_blank" rel="external">http://www.codingmarch.com/</a></td><td>少儿编程教育</td></tr><tr><td>酷拼编程</td><td><a href="http://www.kidsprogram.com.cn/" target="_blank" rel="external">http://www.kidsprogram.com.cn/</a></td><td>开启少儿编程之路</td></tr><tr><td>少儿编程</td><td><a href="http://www.shaoerbianchengwang.com/" target="_blank" rel="external">http://www.shaoerbianchengwang.com/</a></td><td>专注少儿编程教育培训</td></tr><tr><td>编程教育</td><td><a href="http://www.shaoerbc.org/" target="_blank" rel="external">http://www.shaoerbc.org/</a></td><td>少儿教育媒体</td></tr><tr><td>编程中国</td><td><a href="http://codechina.me/" target="_blank" rel="external">http://codechina.me/</a></td><td>儿童编程</td></tr><tr><td>童程童美</td><td><a href="http://www.it61.cn/" target="_blank" rel="external">http://www.it61.cn/</a></td><td>少儿教育</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;国内python学习网站&quot;&gt;&lt;a href=&quot;#国内python学习网站&quot; class=&quot;headerlink&quot; title=&quot;国内python学习网站&quot;&gt;&lt;/a&gt;国内python学习网站&lt;/h4&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;

      
    
    </summary>
    
      <category term="python" scheme="https://songzhiguo.github.io/blogs/categories/python/"/>
    
    
      <category term="python" scheme="https://songzhiguo.github.io/blogs/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>小程序学习笔记</title>
    <link href="https://songzhiguo.github.io/blogs/2018/02/08/small-program/"/>
    <id>https://songzhiguo.github.io/blogs/2018/02/08/small-program/</id>
    <published>2018-02-08T03:28:47.000Z</published>
    <updated>2018-05-25T04:28:46.439Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>微信小程序很小，安装包体积不超过1M，实际上，当用户点击小程序到打开已经经历了从下载到安装，只是这个过程很快，</p><p>微信小程序使用流程简单，跨平台使用</p><h3 id="小程序适合做什么样的应用？"><a href="#小程序适合做什么样的应用？" class="headerlink" title="小程序适合做什么样的应用？"></a>小程序适合做什么样的应用？</h3><blockquote><ul><li>三个特点：</li><li>1、业务逻辑简单，用完即走</li><li>2、使用频率低</li><li>3、性能要求不高</li></ul></blockquote><p>不适合：<br>社区型、直播、复杂手游</p><p>适合：<br>订餐、打车<br>大型应用可拆分部分功能</p><h3 id="移动设备的分辨率与rpx"><a href="#移动设备的分辨率与rpx" class="headerlink" title="移动设备的分辨率与rpx"></a>移动设备的分辨率与rpx</h3><p><img src="https://songzhiguo.github.io/lib/images/px.jpg" alt=""></p><p>pt也称为逻辑分辨率<br>1个pt可以有1个px构成，也可以有2个，还可以有3个甚至更多组成</p><p>pt的大小和屏幕尺寸有关系，简单可以理解为长度和视觉单位</p><p>px指物理分辨率，和屏幕尺寸没有关系。</p><h4 id="小程序如何做不同分辨率设备的自适应"><a href="#小程序如何做不同分辨率设备的自适应" class="headerlink" title="小程序如何做不同分辨率设备的自适应"></a>小程序如何做不同分辨率设备的自适应</h4><p>以iphone6的物理像素750x1334为视觉稿进行设计，而在小程序中使用rpx为单位</p><p>iphone6下 1px = 1rpx = 0.5pt</p><p>使用rpx，小程序会自动在不同分辨率下进行转换，而使用px为单位不会</p><p>不是所有的单位都适合用rpx</p><p>事件中target指的是当前点击的组件 和currentTarget 指的是时间捕获的组件</p><h3 id="页面传参"><a href="#页面传参" class="headerlink" title="页面传参"></a>页面传参</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">catchtap</span>=<span class="string">'onMoreTap'</span> <span class="attr">class</span>=<span class="string">'more'</span> <span class="attr">data-category</span>=<span class="string">"&#123;&#123;catetoryTitle&#125;&#125;"</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 传参</span></div><div class="line">onMoreTap: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> category = enent.currentTarget.dataset.category;</div><div class="line">    wx.navigateTo(&#123;</div><div class="line">    url: <span class="string">"more-movies/more-movies?category="</span> + category</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 获取</span></div><div class="line">onLoad: <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> category = options.category;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="动态设置导航栏标题"><a href="#动态设置导航栏标题" class="headerlink" title="动态设置导航栏标题"></a>动态设置导航栏标题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">onReady: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  wx.setNavigationBarTitle(&#123;</div><div class="line">    title: <span class="keyword">this</span>.data.navigateTitle</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;微信小程序很小，安装包体积不超过1M，实际上，当用户点击小程序到打开已经经历了从下载到安装，只是这个过程很快，&lt;/p&gt;
&lt;p&gt;微信小程序使用流程简单，跨平台使用&lt;/p&gt;
&lt;h3 id=&quot;小程序适合做什么样的应用？&quot;&gt;&lt;a href=&quot;#小
      
    
    </summary>
    
      <category term="program" scheme="https://songzhiguo.github.io/blogs/categories/program/"/>
    
    
      <category term="javascript" scheme="https://songzhiguo.github.io/blogs/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Promise对象</title>
    <link href="https://songzhiguo.github.io/blogs/2018/01/19/es6-Promise/"/>
    <id>https://songzhiguo.github.io/blogs/2018/01/19/es6-Promise/</id>
    <published>2018-01-19T04:36:26.000Z</published>
    <updated>2018-03-12T04:35:27.087Z</updated>
    
    <content type="html"><![CDATA[<p>ES6学习笔记：Promise对象<br><a id="more"></a></p><h3 id="Promise的含义"><a href="#Promise的含义" class="headerlink" title="Promise的含义"></a>Promise的含义</h3><p>Promise是异步编程的一种解决方案</p><p>Promise简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果</p><p>从语法上说，Promise是一个对象，从它可以获取异步操作的消息。</p><p>Promise对象有以下两个特点</p><p>（1）、对象的状态不受外界的影响。Promise对象代表一个异步操作，有三种状态：pending(进行中)、fulfilled(已成功)和rejected(已失败)。只有异步操作的结果，可以决定当前是哪一个状态，任何其他操作都无法改变这个状态。</p><p>（2）、一旦状态改变，就不会在变，任何时候都可以得到这个结果。状态改变，只有两种可能，从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就会凝固，不会在变了会一直保持这个结果，这时就称为resolved</p><p>Promise的缺点：首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知进展到哪一个阶段</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6规定，Promise对象是一个构造函数，用来生成构造函数实例。</p><p>Promise构造函数接受一个函数作为一个参数，该函数的两个参数分别是resolve和reject。他们是两个函数。由javascript引擎提供，不用自己部署。</p><p>resolve函数的作用是，将promise对象的状态从“未完成”变为“成功”，在异步操作成功时调用，并将异步操作的结果，作为参数传递出去。</p><p>jeject函数的作用是，将promise对象的状态从“未完成”变为“失败”，在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p><h3 id="promise-prototype-then"><a href="#promise-prototype-then" class="headerlink" title="promise.prototype.then()"></a>promise.prototype.then()</h3><p>Promise实例具有then方法，也就是说，then方法是定义在原型对象promise.prototype上的，它的作用是为promise实例添加状态改变时的回调函数</p><p>then方法的第一个参数是resloved状态的回调函数，第二个参数（可选）是rejected状态的回调函数</p><p>then方法返回的是一个新的Promise实例（注意，不是原来那个promise实例）。因此可以采用链式写法，既then方法后面在调用另外一个then方法</p><h3 id="promise-prototype-catch"><a href="#promise-prototype-catch" class="headerlink" title="promise.prototype.catch()"></a>promise.prototype.catch()</h3><p>promise.prototype.catch方法是.then(null,rejected)的别名，用于指定发生错误时的回调函数</p><p>promise抛出一个错误，就被catch方法指定的回调函数捕获</p><p>reject方法的作用，等同于抛出错误，如果Promise状态已经变成resolved，在抛出错误时无效的。</p><p>promise对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止，也就是说，错误总是会被下一个catch语句捕获</p><p>一般来说，不要在then方法里面定义 reject 状态的回调函数（即then的第二个参数），总是使用catch方法。</p><p>Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。</p><p>catch方法之中，还能再抛出错误。</p><h3 id="promise-all"><a href="#promise-all" class="headerlink" title="promise.all()"></a>promise.all()</h3><p>promise.all() 方法用于将多个Promise实例，包装成一个新的promise实例</p><p>promise.all()方法接受一个数组作为参数，数组成员都是promise实例，如果不是，就会先调用promise.resolve方法，将参数转为promise实例，再进一步处理。(promise.all方法的参数可以不是数组，但必须具有Iterator接口，且返回的每个成员都是promise实例)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3]);</div></pre></td></tr></table></figure><p>p的状态由p1、p2、p3决定，分成两种情况。</p><p>（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</p><p>（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</p><p>注意，如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。</p><h3 id="promise-race"><a href="#promise-race" class="headerlink" title="promise.race()"></a>promise.race()</h3><p>promise.race()同样是将多个promise实例，包装成一个新的promise实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([p1, p2, p3]);</div></pre></td></tr></table></figure><p>上面代码中，只要p1,p2,p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的promise实例的返回值，就传递给p的回调函数。</p><p>Promise.race方法的参数与Promise.all方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。</p><h3 id="promise-resolve"><a href="#promise-resolve" class="headerlink" title="promise.resolve()"></a>promise.resolve()</h3><p>有时需要将现有对象转为promise对象，promise.resolve方法就起到这个作用</p><p>promise.resolve等价于下面的写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>)</div><div class="line"><span class="comment">// 等价于</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="string">'foo'</span>))</div></pre></td></tr></table></figure><p>promise.resolve方法的参数分成四种情况</p><h4 id="（1）参数是一个-Promise-实例"><a href="#（1）参数是一个-Promise-实例" class="headerlink" title="（1）参数是一个 Promise 实例"></a>（1）参数是一个 Promise 实例</h4><p>如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。</p><h4 id="（2）参数是一个thenable对象"><a href="#（2）参数是一个thenable对象" class="headerlink" title="（2）参数是一个thenable对象"></a>（2）参数是一个thenable对象</h4><p>thenable对象指的是具有then方法的对象，比如下面这个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> thenable = &#123;</div><div class="line">    then: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">        resolve(<span class="number">42</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>Promise.resolve方法会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then方法。</p><h4 id="（3）参数不是具有then方法的对象，或根本就不是对象"><a href="#（3）参数不是具有then方法的对象，或根本就不是对象" class="headerlink" title="（3）参数不是具有then方法的对象，或根本就不是对象"></a>（3）参数不是具有then方法的对象，或根本就不是对象</h4><p>如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的 Promise 对象，状态为resolved。</p><h4 id="（4）不带有任何参数"><a href="#（4）不带有任何参数" class="headerlink" title="（4）不带有任何参数"></a>（4）不带有任何参数</h4><p>Promise.resolve方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。</p><p>所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用Promise.resolve方法。</p><h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h3><p>Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。</p><p>注意，Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。这一点与Promise.resolve方法不一致。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6学习笔记：Promise对象&lt;br&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://songzhiguo.github.io/blogs/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://songzhiguo.github.io/blogs/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Set和Map数据结构</title>
    <link href="https://songzhiguo.github.io/blogs/2018/01/18/es6-set-map/"/>
    <id>https://songzhiguo.github.io/blogs/2018/01/18/es6-set-map/</id>
    <published>2018-01-18T07:30:16.000Z</published>
    <updated>2018-03-12T04:35:31.717Z</updated>
    
    <content type="html"><![CDATA[<p>ES6学习笔记：Set和Map数据结构<br><a id="more"></a></p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>ES6提供的新的数据结构Set。他类似于数组，但是成员值都是唯一值，没有重复值</p><p>Set本身是一个构造函数，用来生成Set数据结构</p><p>Set函数可以接受一个数组（或者具有iterable接口的其他数据结构）作为参数，用来初始化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 去除数组的重复成员</span></div><div class="line">[...new <span class="built_in">Set</span>(array)]</div></pre></td></tr></table></figure><p>向set加入值的时候，不会发生类型转换，set内部判断两个值是否不同，适用算法叫做“Same-value-equality”,他类似精确相等运算符(===)，主要区别是NaN等于自身，而精确相等运算符认为NaN不等于自身</p><h4 id="Set实例的属性和方法"><a href="#Set实例的属性和方法" class="headerlink" title="Set实例的属性和方法"></a>Set实例的属性和方法</h4><p>Set.prototype.constructor：构造函数，默认就是Set函数</p><p>Set.prototype.size：返回Set实例的成员总数。</p><p>Set实例方法分为两大类：</p><p>一、操作方法（用于操作数据）</p><p>add(values)：添加某个值，返回set结构本身</p><p>delete(values)：删除某个值，返回一个布尔值，表示删除是否成功</p><p>has(values)：返回一个布尔值，表示该值是否为Set成员。</p><p>clear()：清楚所有成员，没有返回值。</p><p>Array.from方法可以将Set结构转为数组。</p><p>二、遍历操作</p><p>Set结构的实例四个遍历方法</p><p>keys()：返回键名的遍历器</p><p>values()：返回键值的遍历器</p><p>entries()：返回键值对的遍历器</p><p>forEach()：使用回调函数遍历每个成员</p><p>由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。</p><p>Set结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。</p><p>Set结构的实例方法forEach参数与数组forEach一致，依次为键名、键值、集合本身。另外，forEach方法还可以有第二个参数，表示绑定处理函数的this对象</p><h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><p>WeakSet结构与Set结构类似，也是不重复的值的集合。</p><p>WeakSet结构与Set结构有两个区别，首先WeakSet成员只能是对象，而不能是其他类型的值</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>WeakSet是一个构造函数，可以使用new命令，创建WeakSet数据结构</p><p>作为构造函数，WeakSet可以接受一个数组或类似数组的对象作为参数。该数组的所有成员，都会自动成为WeakSet实例的对象的成员。</p><p>注意，是数组参数的成员成为WeakSet的成员，而不是数组本身，数组参数成员只能是对象</p><p>WeakSet结构有以下三个方法。</p><p>WeakSet.prototype.add(values)：向 WeakSet 实例添加一个新成员。</p><p>WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员。</p><p>WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。</p><p>WeakSet 没有size属性，没有办法遍历它的成员。</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="含义和基本用法"><a href="#含义和基本用法" class="headerlink" title="含义和基本用法"></a>含义和基本用法</h4><p>ES6 提供了 Map 数据结构，它类似于对象，也是键值对的集合，但是键的范围不限于字符串，各种类型的值都可以当做键。</p><p>作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</div><div class="line">    [<span class="string">'name'</span>, <span class="string">'张三'</span>],</div><div class="line">    [<span class="string">'title'</span>, <span class="string">'Author'</span>]</div><div class="line">]);</div><div class="line"></div><div class="line">map.size <span class="comment">// 2</span></div><div class="line">map.has(<span class="string">'name'</span>) <span class="comment">// true</span></div><div class="line">map.get(<span class="string">'name'</span>) <span class="comment">// "张三"</span></div><div class="line">map.has(<span class="string">'title'</span>) <span class="comment">// true</span></div><div class="line">map.get(<span class="string">'title'</span>) <span class="comment">// "Author"</span></div></pre></td></tr></table></figure><p>Set 对象和 Map 对象当作Map构造函数的参数都生成了新的 Map 对象。</p><p>如果对同一个键多次赋值，后面的值将覆盖前面的值。</p><p>如果读取一个未知的键，则返回undefined。</p><p>注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。</p><h4 id="实例的属性和操作方法"><a href="#实例的属性和操作方法" class="headerlink" title="实例的属性和操作方法"></a>实例的属性和操作方法</h4><p>(1)size属性返回 Map 结构的成员总数。</p><p>(2)set(key, value)方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。</p><p>set方法返回的是当前的Map对象，因此可以采用链式写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</div><div class="line">    .set(<span class="number">1</span>, <span class="string">'a'</span>)</div><div class="line">    .set(<span class="number">2</span>, <span class="string">'b'</span>)</div><div class="line">    .set(<span class="number">3</span>, <span class="string">'c'</span>);</div></pre></td></tr></table></figure><p>(3)get(key)方法读取key对应的键值，如果找不到key，返回undefined。</p><p>(4)has(key)方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</p><p>(5)delete(key)delete方法删除某个键，返回true。如果删除失败，返回false。</p><p>(6)clear()clear方法清除所有成员，没有返回值。</p><h4 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h4><p>Map 结构原生提供三个遍历器生成函数和一个遍历方法。</p><p>keys()：返回键名的遍历器。</p><p>values()：返回键值的遍历器。</p><p>entries()：返回所有成员的遍历器。</p><p>forEach()：遍历 Map 的所有成员。</p><p>Map forEach方法，与数组的forEach方法类似，也可以实现遍历。forEach方法还可以接受第二个参数，用来绑定this。</p><h4 id="与其他数据结构转换"><a href="#与其他数据结构转换" class="headerlink" title="与其他数据结构转换"></a>与其他数据结构转换</h4><p>(1)Map 转为数组</p><p>Map 转为数组最方便的方法，就是使用扩展运算符（…）。</p><p>(2)数组 转为 Map</p><p>将数组传入 Map 构造函数，就可以转为 Map。</p><p>(3)Map 转为对象</p><p>如果所有 Map 的键都是字符串，它可以转为对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">strMapToObj</span>(<span class="params">strMap</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> [k,v] <span class="keyword">of</span> strMap) &#123;</div><div class="line">        obj[k] = v;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>()</div><div class="line">    .set(<span class="string">'yes'</span>, <span class="literal">true</span>)</div><div class="line">    .set(<span class="string">'no'</span>, <span class="literal">false</span>);</div><div class="line">strMapToObj(myMap)</div></pre></td></tr></table></figure><p>(4)对象转为 Map</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">objToStrMap</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> strMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj)) &#123;</div><div class="line">        strMap.set(k, obj[k]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> strMap;</div><div class="line">&#125;</div><div class="line"></div><div class="line">objToStrMap(&#123;<span class="attr">yes</span>: <span class="literal">true</span>, <span class="attr">no</span>: <span class="literal">false</span>&#125;)</div></pre></td></tr></table></figure><p>(5)Map 转为 JSON</p><p>Map 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。</p><p>另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。</p><h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><h4 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h4><p>WeakMap结构与Map结构类似，也是用于生成键值对的集合</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// WeakMap 可以使用 set 方法添加成员</span></div><div class="line"><span class="keyword">const</span> wm1 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</div><div class="line"><span class="keyword">const</span> key = &#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;;</div><div class="line">wm1.set(key, <span class="number">2</span>);</div><div class="line">wm1.get(key) <span class="comment">// 2</span></div><div class="line"></div><div class="line"><span class="comment">// WeakMap 也可以接受一个数组，</span></div><div class="line"><span class="comment">// 作为构造函数的参数</span></div><div class="line"><span class="keyword">const</span> k1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"><span class="keyword">const</span> k2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</div><div class="line"><span class="keyword">const</span> wm2 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>([[k1, <span class="string">'foo'</span>], [k2, <span class="string">'bar'</span>]]);</div><div class="line">wm2.get(k2) <span class="comment">// "bar"</span></div></pre></td></tr></table></figure><h5 id="WeakMap与Map的区别有两点。"><a href="#WeakMap与Map的区别有两点。" class="headerlink" title="WeakMap与Map的区别有两点。"></a>WeakMap与Map的区别有两点。</h5><p>首先WeakMap只接受对象作为键名除外，不接受其他类型的值作为键名。</p><p>其次WeakMap的键名所指向的对象，不计入垃圾回收机制</p><p>WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏。</p><p>注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。</p><h4 id="WeakMap-的语法"><a href="#WeakMap-的语法" class="headerlink" title="WeakMap 的语法"></a>WeakMap 的语法</h4><p>WeakMap 与 Map 在 API 上的区别主要是两个，一是没有遍历操作（即没有key()、values()和entries()方法），也没有size属性。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6学习笔记：Set和Map数据结构&lt;br&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://songzhiguo.github.io/blogs/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://songzhiguo.github.io/blogs/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Module 的语法</title>
    <link href="https://songzhiguo.github.io/blogs/2018/01/18/module/"/>
    <id>https://songzhiguo.github.io/blogs/2018/01/18/module/</id>
    <published>2018-01-18T03:48:36.000Z</published>
    <updated>2018-06-27T03:11:50.214Z</updated>
    
    <content type="html"><![CDATA[<p>Module实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。<br><a id="more"></a></p><h3 id="export命令"><a href="#export命令" class="headerlink" title="export命令"></a>export命令</h3><p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">let</span> firstName = <span class="string">'song'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">let</span> lastName = <span class="string">'zhiguo'</span>;</div></pre></td></tr></table></figure><p>export的写法，除了像上面这样，还有另外一种。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> firstName = <span class="string">'song'</span>;</div><div class="line"><span class="keyword">let</span> lastName = <span class="string">'zhiguo'</span>;</div><div class="line"><span class="keyword">export</span> &#123; firstName, lastName &#125;;</div></pre></td></tr></table></figure><p>export命令除了输出变量，还可以输出函数或类（class）<br>通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">firstName</span> (<span class="params"></span>) </span>&#123;...&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">lastName</span> (<span class="params"></span>) </span>&#123;...&#125;</div><div class="line"><span class="keyword">export</span> &#123;</div><div class="line">  firstName <span class="keyword">as</span> first,</div><div class="line">  lastName <span class="keyword">as</span> last </div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="import命令"><a href="#import命令" class="headerlink" title="import命令"></a>import命令</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; firstName, lastName &#125; <span class="keyword">from</span> <span class="string">'...'</span>;</div></pre></td></tr></table></figure><p>如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; firstName <span class="keyword">as</span> first &#125; <span class="keyword">from</span> <span class="string">'...'</span>;</div></pre></td></tr></table></figure><h3 id="模块的整体加载"><a href="#模块的整体加载" class="headerlink" title="模块的整体加载"></a>模块的整体加载</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a.js</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">let</span> firstName = <span class="string">'song'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">let</span> lastName = <span class="string">'zhiguo'</span>;</div><div class="line"></div><div class="line"><span class="comment">// b.js</span></div><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> name <span class="keyword">from</span> <span class="string">'...'</span>;</div><div class="line"><span class="built_in">console</span>.log(name.firstName);</div><div class="line"><span class="built_in">console</span>.log(name.lastName);</div></pre></td></tr></table></figure><h3 id="export-default-命令"><a href="#export-default-命令" class="headerlink" title="export default 命令"></a>export default 命令</h3><p>指定默认输出<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">'...'</span>;</div></pre></td></tr></table></figure><p>使用export default时，对应的import语句不需要使用大括号。不使用export default时，对应的import语句需要使用大括号。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">crc32</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 输出&#125;</span></div><div class="line"><span class="keyword">import</span> crc32 <span class="keyword">from</span> <span class="string">'crc32'</span>; <span class="comment">// 输入</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">crc32</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 输出&#125;;</span></div><div class="line"><span class="keyword">import</span> &#123;crc32&#125; <span class="keyword">from</span> <span class="string">'crc32'</span>; <span class="comment">// 输入</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Module实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。&lt;br&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://songzhiguo.github.io/blogs/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://songzhiguo.github.io/blogs/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>ES6学习笔记：Symbol</title>
    <link href="https://songzhiguo.github.io/blogs/2018/01/18/es6-symbol/"/>
    <id>https://songzhiguo.github.io/blogs/2018/01/18/es6-symbol/</id>
    <published>2018-01-18T03:48:36.000Z</published>
    <updated>2018-03-12T04:35:38.149Z</updated>
    
    <content type="html"><![CDATA[<p>ES6学习笔记：Symbol<br><a id="more"></a></p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>ES6引入一种新的原始数据类型，表示独一无二的值。它是javascript语言的第七种数据类型，前六种是：undefined、null、布尔值、字符串、数值、对象</p><p>symbol值通过函数生成。对象的属性名现在可以有两种类型，一种是原来就有的字符串，另外一种就是新增的symbol类型，凡是属性名属于symbol类型，就是独一无二的。</p><p>注意，symbol函数前不接受new命令，否则会报错，这是应为symbol是一个原始类型的值，不是对象。基本是，symbol是一种类似字符串的数据类型</p><p>symbol函数可以接受一个字符串作为参数，表示对symbol实例的描述。</p><p>如果symbol的参数是一个对象，就会调用该对象的tostring方法，将其转为字符串，然后才生成一个symbol值</p><p>注意，symbol函数的参数只是表示当前symbol值的描述，相同参数的symbol函数的返回值是不相等的</p><p>symbol值不能与其他类型的值进行运算，会报错</p><p>symbol值可以显式的转为字符串，也可以转为布尔值，但不能转为数值。</p><h3 id="作为属性名的symbol值"><a href="#作为属性名的symbol值" class="headerlink" title="作为属性名的symbol值"></a>作为属性名的symbol值</h3><p>symbol值作为对象属性名时，不能用点运算。</p><p>在对象内部，使用Symbol值定义属性时，Symbol值必须放在方括号之中。</p><p>symbol值作为属性名时，该属性还是公开属性，不是私有属性</p><h3 id="实例：消除魔术字符串"><a href="#实例：消除魔术字符串" class="headerlink" title="实例：消除魔术字符串"></a>实例：消除魔术字符串</h3><p>魔术字符串指的是，在代码中多次出现，与代码形成强耦合的某一具体的字符串或者数值。</p><h3 id="属性名的遍历"><a href="#属性名的遍历" class="headerlink" title="属性名的遍历"></a>属性名的遍历</h3><p>Symbol作为属性名，该属性不会出现在for…in、for…of循环中，也不会被object.key()、object.getOwnPropertyNames()、JSON.stringify()返回，但是他也不是私有属性，有一个object.getOwnPropertySymbols方法，可以获取指定对象的所有Symobl属性名。</p><p>object.getOwnPropertySymbols方法返回一个数组，成员是当前对象的所有用作属性名的Symbol值</p><p>Reflect.ownKeys方法可以返回所有类型的键名，包括常规键名和symbol键名</p><h3 id="symbol-for-symbol-keyFor"><a href="#symbol-for-symbol-keyFor" class="headerlink" title="symbol.for(),symbol.keyFor()"></a>symbol.for(),symbol.keyFor()</h3><p>symbol.for()与symbol()这两种写法，都会生成新的Symbol,他们的区别是，前者会被登记在全局环境中供搜索，后者不会。Symbol.for()不会每次调用就返回一个新的Symbol类型的值，而是会先检查给定key是否存在，如果不存在才会创建一个新值。后者调用几次就返回几个不同的symbol值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Symbol</span>.for(<span class="string">"bar"</span>) === <span class="built_in">Symbol</span>.for(<span class="string">"bar"</span>)</div><div class="line"><span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">Symbol</span>(<span class="string">"bar"</span>) === <span class="built_in">Symbol</span>(<span class="string">"bar"</span>)</div><div class="line"><span class="comment">// false</span></div></pre></td></tr></table></figure><p>symbol.keyFor()方法返回一个已登记的Symbol类型值的key</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>);</div><div class="line"><span class="built_in">Symbol</span>.keyFor(s1) <span class="comment">// "foo"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</div><div class="line"><span class="built_in">Symbol</span>.keyFor(s2) <span class="comment">// undefined</span></div></pre></td></tr></table></figure><h3 id="实例：模块的singleton模式"><a href="#实例：模块的singleton模式" class="headerlink" title="实例：模块的singleton模式"></a>实例：模块的singleton模式</h3><p>singleton模式指的是调用一个类，任何时候返回的都是同一个实例</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6学习笔记：Symbol&lt;br&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://songzhiguo.github.io/blogs/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://songzhiguo.github.io/blogs/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>对象的扩展</title>
    <link href="https://songzhiguo.github.io/blogs/2018/01/15/es6-object/"/>
    <id>https://songzhiguo.github.io/blogs/2018/01/15/es6-object/</id>
    <published>2018-01-15T10:48:00.000Z</published>
    <updated>2018-03-12T04:35:21.825Z</updated>
    
    <content type="html"><![CDATA[<p>ES6学习笔记：对象的扩展<br><a id="more"></a></p><h3 id="属性的简介表示法"><a href="#属性的简介表示法" class="headerlink" title="属性的简介表示法"></a>属性的简介表示法</h3><p>ES6允许直接写入变量和函数，作为对象的属性和方法，书写更加简洁</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> foo = <span class="string">'bar'</span>;</div><div class="line"><span class="keyword">const</span> baz = &#123;foo&#125;;</div><div class="line">baz <span class="comment">//&#123;foo: "bar"&#125;</span></div></pre></td></tr></table></figure><p>ES6允许在对象中，直接写变量。这时，属性名为变量名，属性值为变量的值。</p><h3 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h3><p>javascript定义对象的属性，有两种方法</p><p>方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号内。</p><p>ES6允许字面量定义对象时，用方法二（表达式）作为对象的属性名，既把表达式放在方括号内</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> propkey = <span class="string">'foo'</span>;</div><div class="line"></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    [prokey]: <span class="literal">true</span>,</div><div class="line">    [<span class="string">'a'</span>+<span class="string">'b'</span>]: <span class="number">123</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>表达式还可以定义方法名</p><p>注意，属性名表达式与简洁表示法，不能同时使用，会报错。如果表达式是一个对象，默认情况下会自动将对象转为字符串[object object]。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> keyA = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</div><div class="line"><span class="keyword">const</span> keyB = &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> myObject = &#123;</div><div class="line">  [keyA]: <span class="string">'valueA'</span>,</div><div class="line">  [keyB]: <span class="string">'valueB'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">myObject <span class="comment">// Object &#123;[object Object]: "valueB"&#125;</span></div></pre></td></tr></table></figure><p>[keyA]和[keyB]得到的都是[object Object],所以[keyB]会把[keyA]覆盖掉，而myObject最后只有一个[object Object]属性。</p><h3 id="方法的name值"><a href="#方法的name值" class="headerlink" title="方法的name值"></a>方法的name值</h3><p>函数的name属性，返回函数名。对象方法也是函数，因此也有name属性</p><p>方法的name属性返回函数名(既方法名)</p><h3 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h3><p>ES5比较两个值是否相等，只有两个运算符：相等运算符(==)和严格相等运算符(===)。他们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0。</p><p>Object.is()用来比较两个值是否严格相等，与严格比较云算符(===)的行为基本一致。不同之处只有两个：<br>一是+0不等于-0，二是NaN等于自身。</p><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>Object.assign()方法用于对象的合并，将原对象的所有可枚举属性，复制到目标对象</p><p>第一个参数是目标对象，后面的参数都是原对象</p><p>注意，如果目标对象与原对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p><p>如果只有一个参数，Object.assign会直接返回该参数</p><p>如果该参数不是对象，则会先转成对象，然后返回</p><p>由于undefined和null无法转成对象，所以如果他们作为参数，就会报错</p><p>如果非对象参数出现在源对象的位置（既非首参数），那么处理规则则有不同。首先这些参数都会转为对象，如果无法转为对象，就会跳过，这意味着，如果undefined和null不在首参数，就不会报错。</p><p>其他类型的值（既数值、字符串、布尔值）不在首参数，也不会报错。但是除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。这是应为只有字符串的的包装对象会产生可枚举属性。</p><p>Object.assign拷贝属性是有限的，只拷贝原对象的自身属性（不拷贝继承属性），也不拷贝不可枚举属性。</p><p>属性名为Symbol值的属性,也会被Object.assign拷贝</p><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><h5 id="一、浅拷贝"><a href="#一、浅拷贝" class="headerlink" title="一、浅拷贝"></a>一、浅拷贝</h5><p>Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</p><h5 id="二、同名属性的替换"><a href="#二、同名属性的替换" class="headerlink" title="二、同名属性的替换"></a>二、同名属性的替换</h5><p>对于这种嵌套的对象，一旦遇到同名属性，Object.assign的处理方法是替换，而不是添加</p><h5 id="三、数组的处理"><a href="#三、数组的处理" class="headerlink" title="三、数组的处理"></a>三、数组的处理</h5><p>Object.assign可以用来处理数组，但是会被数组视为对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.assign([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>])</div><div class="line"><span class="comment">// [4, 5, 3]</span></div></pre></td></tr></table></figure><h5 id="四取值函数的处理"><a href="#四取值函数的处理" class="headerlink" title="四取值函数的处理"></a>四取值函数的处理</h5><p>Object.assign只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后在复制</p><h4 id="常用用途"><a href="#常用用途" class="headerlink" title="常用用途"></a>常用用途</h4><h5 id="一、为对象添加属性"><a href="#一、为对象添加属性" class="headerlink" title="一、为对象添加属性"></a>一、为对象添加属性</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(x, y) &#123;</div><div class="line">        <span class="built_in">Object</span>.assign(<span class="keyword">this</span>, &#123;x, y&#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h5 id="二、为对象添加方法"><a href="#二、为对象添加方法" class="headerlink" title="二、为对象添加方法"></a>二、为对象添加方法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.assign(SomeClass.prototype, &#123;</div><div class="line">    someMethod(arg1, arg2) &#123;</div><div class="line">        ···</div><div class="line">    &#125;,</div><div class="line">    anotherMethod() &#123;</div><div class="line">        ···</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 等同于下面的写法</span></div><div class="line">SomeClass.prototype.someMethod = <span class="function"><span class="keyword">function</span> (<span class="params">arg1, arg2</span>) </span>&#123;</div><div class="line">···</div><div class="line">&#125;;</div><div class="line">SomeClass.prototype.anotherMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">···</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h4 id="三、克隆对象"><a href="#三、克隆对象" class="headerlink" title="三、克隆对象"></a>三、克隆对象</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">origin</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, origin);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值</p><h4 id="四、合并多个对象"><a href="#四、合并多个对象" class="headerlink" title="四、合并多个对象"></a>四、合并多个对象</h4><p>将多个对象合并到某个对象</p><h4 id="五、为属性指定默认值"><a href="#五、为属性指定默认值" class="headerlink" title="五、为属性指定默认值"></a>五、为属性指定默认值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> DEFAULTS = &#123;</div><div class="line">    logLevel: <span class="number">0</span>,</div><div class="line">    outputFormat: <span class="string">'html'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">processContent</span>(<span class="params">options</span>) </span>&#123;</div><div class="line">    options = <span class="built_in">Object</span>.assign(&#123;&#125;, DEFAULTS, options);</div><div class="line">    <span class="built_in">console</span>.log(options);</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="属性的可枚举性和遍历"><a href="#属性的可枚举性和遍历" class="headerlink" title="属性的可枚举性和遍历"></a>属性的可枚举性和遍历</h3><h4 id="可枚举性"><a href="#可枚举性" class="headerlink" title="可枚举性"></a>可枚举性</h4><p>对象的每个属性都有一个描述对象，用来控制该属性的行为。</p><p>Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</div><div class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'foo'</span>)</div><div class="line"><span class="comment">//  &#123;</span></div><div class="line"><span class="comment">//    value: 123,</span></div><div class="line"><span class="comment">//    writable: true,</span></div><div class="line"><span class="comment">//    enumerable: true,</span></div><div class="line"><span class="comment">//    configurable: true</span></div><div class="line"><span class="comment">//  &#125;</span></div></pre></td></tr></table></figure><p>描述对象的enumerable属性，称为“可枚举性”，如果该属性为false,就表示某些操作会忽略当前属性</p><p>目前，有四个操作会忽略enumerable为fales的属性。</p><blockquote><ul><li>  for…in循环：只遍历对象自身的和继承的可枚举的属性。<br>  Object.keys()：返回对象自身的所有可枚举的属性的键名。<br>  JSON.stringify()：只串行化对象自身的可枚举的属性。<br>  Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。</li><li></li></ul></blockquote><p>这四个操作之中,只有for…in会返回继承的属性，其他三个方法都会忽略继承的属性，只处理对象自身的属性。</p><p>实际上，引入“可枚举”（enumerable）这个概念的最初目的，就是让某些属性可以规避掉for…in操作，不然所有内部属性和方法都会被遍历到。比如，对象原型的toString方法，以及数组的length属性，就通过“可枚举性”，从而避免被for…in遍历到。</p><p>toString和length属性的enumerable都是false，因此for…in不会遍历到这两个继承自原型的属性。</p><p>另外，ES6 规定，所有 Class 的原型的方法都是不可枚举的。</p><p>总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用for…in循环，而用Object.keys()代替。</p><h4 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h4><p>ES6 一共有 5 种方法可以遍历对象的属性。</p><p>(1)for…in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</p><p>(2)Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</p><p>(3)Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</p><p>(4)bject.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。</p><p>(5)Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</p><p>以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。</p><blockquote><p>-<br>    首先遍历所有数值键，按照数值升序排列。<br>    其次遍历所有字符串键，按照加入时间升序排列。<br>    最后遍历所有 Symbol 键，按照加入时间升序排列。<br>-</p></blockquote><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">Reflect</span><span class="selector-class">.ownKeys</span>(&#123; <span class="selector-attr">[Symbol()]</span><span class="selector-pseudo">:0</span>, <span class="selector-tag">b</span><span class="selector-pseudo">:0</span>, <span class="selector-tag">10</span><span class="selector-pseudo">:0</span>, <span class="selector-tag">2</span><span class="selector-pseudo">:0</span>, <span class="selector-tag">a</span><span class="selector-pseudo">:0</span> &#125;)</div><div class="line"><span class="comment">// ['2', '10', 'b', 'a', Symbol()]</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6学习笔记：对象的扩展&lt;br&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://songzhiguo.github.io/blogs/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://songzhiguo.github.io/blogs/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>数组的扩展</title>
    <link href="https://songzhiguo.github.io/blogs/2018/01/12/es6_array/"/>
    <id>https://songzhiguo.github.io/blogs/2018/01/12/es6_array/</id>
    <published>2018-01-12T09:47:26.000Z</published>
    <updated>2018-03-12T04:32:36.380Z</updated>
    
    <content type="html"><![CDATA[<p>ES6学习笔记：数组的扩展<br><a id="more"></a></p><h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><p>扩展运算符（spread）是三个点…，它好比是rest参数的逆运算，将一个数组转化为用逗号分隔的参数序列。</p><p>该运算符主要用于函数调用。</p><p>扩展运算符与正常的函数参数可以结合使用</p><p>扩展运算符后面还可以放置表达式</p><p>如果扩展运算符后面是一个空数组，则不产生任何效果<br><!-- more --></p><h4 id="扩展运算符的应用"><a href="#扩展运算符的应用" class="headerlink" title="扩展运算符的应用"></a>扩展运算符的应用</h4><h5 id="（1）复制数组"><a href="#（1）复制数组" class="headerlink" title="（1）复制数组"></a>（1）复制数组</h5><p>扩展运算符提供了复制数组的简便写法。返回原数组的克隆</p><h5 id="（2）合并数组"><a href="#（2）合并数组" class="headerlink" title="（2）合并数组"></a>（2）合并数组</h5><p>扩展运算符提供了数组合并的新写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr1 = [<span class="string">'a'</span>, <span class="string">'b'</span>];</div><div class="line"><span class="keyword">var</span> arr2 = [<span class="string">'c'</span>];</div><div class="line"><span class="keyword">var</span> arr3 = [<span class="string">'d'</span>, <span class="string">'e'</span>];</div><div class="line">[...arr1, ...arr2, ...arr3]</div></pre></td></tr></table></figure><h5 id="3-与解构赋值结合"><a href="#3-与解构赋值结合" class="headerlink" title="(3)与解构赋值结合"></a>(3)与解构赋值结合</h5><p>扩展运算符可以与解构赋值结合起来，用于生成数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line">first <span class="comment">// 1</span></div><div class="line">rest  <span class="comment">// [2, 3, 4, 5]</span></div></pre></td></tr></table></figure><p>如果扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</p><h5 id="（4）字符串"><a href="#（4）字符串" class="headerlink" title="（4）字符串"></a>（4）字符串</h5><p>扩展运算符还可以将字符串转为真正的数组</p><p>扩展运算符能够正确识别四个字节的Unicode字符</p><h5 id="（5）实现了Iterator接口对象"><a href="#（5）实现了Iterator接口对象" class="headerlink" title="（5）实现了Iterator接口对象"></a>（5）实现了Iterator接口对象</h5><p>任何Iterator接口的对象，都可以用扩展运算符转为真正的数组</p><p>没有部署Iterator接口，扩展运算符就会报错</p><h3 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h3><p>Array.from()方法用于两类对象转为真正的数组：类似数组的对象和可遍历的对象</p><p>如果参数是一个真正的数组，Array.form()会返回一个一模一样的新数组</p><p>扩展运算符背后调用的是遍历器接口，如果一个对象没有部署这个接口，就无法转换。</p><p>Array.from()方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，既必须有length属性。</p><p>因此，任何有length属性的对象，都可以通过Array.from()方法转为数组，而此时扩展运算符就无法转换</p><p>Array.from()还可以接受第二个参数，作为类似数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p><p>Array.from()的另一个应用，将字符串转为数组，然后返回字符串的长度，可以避免javascript将大于\uFFFF的Unicode字符，算作两个字符的BUG</p><h3 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h3><p>Array.of()方法用于将一组值，转换为数组，弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异</p><p>Array.of基本可以代替Array()或new Array(),总是返回参数值组成的数组。如果没有参数就返回一个而空数组。</p><p>Array.of的方法可以用下面代码来实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayOf</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> [].slice.call(<span class="built_in">arguments</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="数组实例的copyWithin"><a href="#数组实例的copyWithin" class="headerlink" title="数组实例的copyWithin()"></a>数组实例的copyWithin()</h3><p>数组实例的copyWithin()方法，在当前数组内部，将指定位置的成员复制到其他位置(会覆盖其他成员)，然后返回当前数组，会改变当前数组</p><p>接受三个参数</p><blockquote><ul><li>-target(必须)：从该位置替换数据。如果未负值，表示倒数。<br>-star(可选)：从该位置读取数据，默认为0。如果为负值，表示倒数。<br>-end(可选)：到该位置前停止读取数据，默认等于数组的长度。如果为负值表示倒数。</li><li></li></ul></blockquote><p>这三个参数都应该是数值，如果不是，会自动转为数值</p><h3 id="数组实例的find-和findIndex"><a href="#数组实例的find-和findIndex" class="headerlink" title="数组实例的find()和findIndex()"></a>数组实例的find()和findIndex()</h3><p>数组实例的find()方法用于找出第一个符合条件的数组成员。他的参数是一个回调函数，所有成员依次执行该回调函数，直到找到第一个返回true的成员，然后返回该成员，如果没有符合条件的成员，则返回undefined。</p><p>find()方法的回调函数可以接受三个参数，依次为当前值、当前位置和原数组</p><p>数组实例的Indexfind()的方法与find()方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。</p><p>两个方法都可以接受第二个参数，用来绑定回调函数中的this对象</p><h3 id="数组实例的fill"><a href="#数组实例的fill" class="headerlink" title="数组实例的fill()"></a>数组实例的fill()</h3><p>fill()方法使用给定值，填充一个数组</p><p>fill()方法还可以接受第二个参数和第三个参数，用于指定填充起始位置和结束位置</p><h3 id="数组实例的entries-keys-values"><a href="#数组实例的entries-keys-values" class="headerlink" title="数组实例的entries(),keys(),values()"></a>数组实例的entries(),keys(),values()</h3><p>es6提供三个新的方法–entries(),keys(),values()—用于遍历数组。他们都返回一个遍历器对象，可用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历</p><h3 id="数组实例的includes"><a href="#数组实例的includes" class="headerlink" title="数组实例的includes()"></a>数组实例的includes()</h3><p>Array.prototype.includes()方法返回一个布尔值，表示某个数组中是否包含给定值，与字符串的includes方法类似</p><p>该方法的第二个参数表示搜索的起始位置，默认为0,如果第二个参数为负值，则表示倒数的位置，如果这是他大于数组的长度，则会重置为从0开始</p><h3 id="数组的空位"><a href="#数组的空位" class="headerlink" title="数组的空位"></a>数组的空位</h3><p>数组的空位指，数组的某一位没有任何值</p><p>注意空位不是undefined,一个位置的值等于undefined，依然是有值的，空位是没有任何值</p><p>ES6则明确将空位转为undefined</p><p>由于空位处理规则非常不统一，所以避免出现空位</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6学习笔记：数组的扩展&lt;br&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://songzhiguo.github.io/blogs/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://songzhiguo.github.io/blogs/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>函数的扩展</title>
    <link href="https://songzhiguo.github.io/blogs/2018/01/11/es6_function/"/>
    <id>https://songzhiguo.github.io/blogs/2018/01/11/es6_function/</id>
    <published>2018-01-11T09:29:41.000Z</published>
    <updated>2018-03-12T04:35:06.871Z</updated>
    
    <content type="html"><![CDATA[<p>ES6学习笔记：函数的扩展<br><a id="more"></a></p><h3 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x, y = <span class="string">'World'</span></span>) </span>&#123;</div><div class="line"><span class="built_in">console</span>.log(x, y);</div><div class="line">&#125;</div><div class="line"></div><div class="line">log(<span class="string">'Hello'</span>) <span class="comment">// Hello World</span></div><div class="line">log(<span class="string">'Hello'</span>, <span class="string">'China'</span>) <span class="comment">// Hello China</span></div><div class="line">log(<span class="string">'Hello'</span>, <span class="string">''</span>) <span class="comment">// Hello</span></div></pre></td></tr></table></figure><p>参数变量是默认声明的，所以不能用let或const再次声明。</p><p>使用参数默认值时，函数不能有同名参数。</p><p>参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。</p><h4 id="与解构赋值默认值结合使用"><a href="#与解构赋值默认值结合使用" class="headerlink" title="与解构赋值默认值结合使用"></a>与解构赋值默认值结合使用</h4><p>参数默认值可以与解构赋值的默认值，结合起来使用。</p><h4 id="参数默认值的位置"><a href="#参数默认值的位置" class="headerlink" title="参数默认值的位置"></a>参数默认值的位置</h4><p>通常情况下，定义了默认值的参数，应该是函数的为参数。如果非尾部的参数设置了默认值，实际上这个参数是没有办法省略的</p><p>如果传入undefined，将触发该参数等于默认值，null则没有这个效果。</p><h4 id="函数的length属性"><a href="#函数的length属性" class="headerlink" title="函数的length属性"></a>函数的length属性</h4><p>指定了默认值之后，函数的length属性，将返回没有指定默认值的参数个数。</p><p>如果设置的默认值不是尾参数，那么length属性也不再计入后边的参数</p><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域。等到初始化结束，这个作用域就会消失，这种语法行为，在不设置参数默认值时，是不会出现的</p><h3 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h3><p>ES6引入rest参数（形式为…变量名），用于获取函数的多余参数，rest参数搭配的变量是一个数组，该变量多余的参数放入数组中</p><p>注意，rest参数之后不能再有其他参数，否则会报错</p><p>函数的length属性，不包括rest参数</p><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>ES6规定，只要函数参数使用的默认值、结构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错</p><p>有两种方法可以规避这种显示：<br>一、设定全局的严格模式，这是合法的<br>二、把函数包在一个无参数的立即执行函数里</p><h3 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h3><p>函数的name属性返回函数的函数名</p><p>如果讲一个匿名函数赋值给一个变量，ES5的name属性会返回一个空字符串，而ES6的name属性则会返回实际的函数名</p><p>如果将一个具名函数赋值给一个变量，则ES5，ES6的neme属性都返回这个具名函数原本的名字</p><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>ES6允许使用=&gt;定义函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> v;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果箭头函数不需要参数或者需要多个参数，就是用一个圆括号代表参数部分</p><p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将他们括起来，并且使用return语句返回</p><p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外边加上大括号，否则会报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 报错</span></div><div class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> &#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">"Temp"</span> &#125;;</div><div class="line"></div><div class="line"><span class="comment">// 不报错</span></div><div class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> (&#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">"Temp"</span> &#125;);</div></pre></td></tr></table></figure><blockquote><ul><li>  箭头函数有几个使用注意点。<br>  (1)函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象<br>  (2)不可当做构造函数，也就是说，不可以使用new命令，否则会抛出一个错误<br>  (3)不可使用arguments对象，该对象在函数体内不存在，如果要用可以用rest参数代替<br>  (4)不可以使用yield命令，因此箭头函数不能用作Generator函数</li><li></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6学习笔记：函数的扩展&lt;br&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://songzhiguo.github.io/blogs/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://songzhiguo.github.io/blogs/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>字符串的扩展</title>
    <link href="https://songzhiguo.github.io/blogs/2018/01/09/es6_string/"/>
    <id>https://songzhiguo.github.io/blogs/2018/01/09/es6_string/</id>
    <published>2018-01-09T13:32:40.000Z</published>
    <updated>2018-03-12T04:35:17.295Z</updated>
    
    <content type="html"><![CDATA[<p>ES6学习笔记：字符串的扩展<br><a id="more"></a></p><h3 id="字符的Unicode表示法"><a href="#字符的Unicode表示法" class="headerlink" title="字符的Unicode表示法"></a>字符的Unicode表示法</h3><p>JavaScript 允许采用\uxxxx形式表示一个字符，其中xxxx表示字符的 Unicode 码点。</p><p>但是，这种表示法只限于码点在\u0000~\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。</p><p>ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。</p><h3 id="codepointAt"><a href="#codepointAt" class="headerlink" title="codepointAt()"></a>codepointAt()</h3><p>JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode 码点大于0xFFFF的字符），JavaScript 会认为它们是两个字符。</p><p>汉字“𠮷”（注意，这个字不是“吉祥”的“吉”）的码点是0x20BB7，UTF-16 编码为0xD842 0xDFB7（十进制为55362 57271），需要4个字节储存。对于这种4个字节的字符，JavaScript 不能正确处理，字符串长度会误判为2，而且charAt方法无法读取整个字符，charCodeAt方法只能分别返回前两个字节和后两个字节的值。</p><p>ES6 提供了codePointAt方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。</p><p>总之，codePointAt方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与charCodeAt方法相同。</p><p>codePointAt方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">is32Bit</span>(<span class="params">c</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> c.codePointAt(<span class="number">0</span>) &gt; <span class="number">0xFFFF</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">is32Bit(<span class="string">"𠮷"</span>) <span class="comment">// true</span></div><div class="line">is32Bit(<span class="string">"a"</span>) <span class="comment">// false</span></div></pre></td></tr></table></figure><h3 id="String-fromCodePoint"><a href="#String-fromCodePoint" class="headerlink" title="String.fromCodePoint()"></a>String.fromCodePoint()</h3><p>ES5 提供String.fromCharCode方法，用于从码点返回对应字符，但是这个方法不能识别 32 位的 UTF-16 字符（Unicode 编号大于0xFFFF）。</p><p>ES6 提供了String.fromCodePoint方法，可以识别大于0xFFFF的字符，弥补了String.fromCharCode方法的不足。在作用上，正好与codePointAt方法相反。</p><p>注意，fromCodePoint方法定义在String对象上，而codePointAt方法定义在字符串的实例对象上。</p><h3 id="字符串的遍历器接口"><a href="#字符串的遍历器接口" class="headerlink" title="字符串的遍历器接口"></a>字符串的遍历器接口</h3><p>ES6 为字符串添加了遍历器接口，使得字符串可以被for…of循环遍历。</p><p>除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。</p><h3 id="includes-startsWith-endsWith"><a href="#includes-startsWith-endsWith" class="headerlink" title="includes(), startsWith(), endsWith()"></a>includes(), startsWith(), endsWith()</h3><p>includes()：返回布尔值，表示是否找到了参数字符串。</p><p>startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。</p><p>endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。</p><h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h3><p>repeat方法返回一个新字符串，表示将原字符串重复n次。</p><p>参数如果是小数，会被取整。</p><p>如果repeat的参数是负数或者Infinity，会报错。</p><p>但是，如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于-0，repeat视同为 0。</p><p>参数NaN等同于 0。</p><p>如果repeat的参数是字符串，则会先转换成数字。</p><h3 id="padStart-，padEnd"><a href="#padStart-，padEnd" class="headerlink" title="padStart()，padEnd()"></a>padStart()，padEnd()</h3><p>ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。</p><p>如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。</p><p>如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。</p><p>如果省略第二个参数，默认使用空格补全长度</p><p>padStart的常见用途是为数值补全指定位数</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6学习笔记：字符串的扩展&lt;br&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://songzhiguo.github.io/blogs/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://songzhiguo.github.io/blogs/tags/javascript/"/>
    
  </entry>
  
</feed>
